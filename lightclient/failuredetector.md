***This is the beginning of an unfinished draft. Don't continue reading!***

# Failure detector

A failure detector is a process that gets as input a header with some height *h*, connects to different Tendermint full nodes, requests the header of height *h* from them, and then cross-checks the headers and the input header.

There are two foreseeable use cases:

1) strengthen the lite client: If a lite client accepts a header *hd* (after performing skipping or sequential verification), it can use the failure detector to probe the system for conflicting headers and increase the trust in *hd*. Instead of communicating with a single full node, communicating with several full nodes shall increase the likelihood to be aware of a fork in case there is one.

2) to support fork accountability: In the case when more than 1/3 of the voting power is held by faulty validators, faulty nodes may generate two conflicting headers for the same height. The goal of the failure detector is to learn about the conflicting headers by probing different full nodes. Once a failure detector has two conflicting headers, these headers are evidence of misbehavior. A natural extension is to use the failure detector within a monitor process (on a full node) that calls the failure detector on a sample (or all) headers (in parallel). (If the sample is chosen at random, this adds a level of probabilistic reasoning.) If conflicting headers are found, they are evidence that can be used for punishing processes.

In this document we will focus in strengthening the lite client, and leave other uses of the failure detection mechanism (e.g., when run on a full node) to the future.

This document refers to the lite client ADR  [[lightclient]]. If not
familiar with the light client, the ADR gives a good overview.

## Context of this document

The lite client verification specification [[verification]] is
designed for the Tendermint failure model (1/3 assumption)
[[TMBC-FM-2THIRDS-link]]. It is safe under this assumption, and life
if it can reliably and timely communicate with a correct full node. If
this assumption is violated, the lite client can be fooled to trust a
header that was not generated by Tendermint consensus.

This specification, the failure detector, is a "second line of defense", in case the 1/3 assumption is violated. Its goal is to collect evidence. However, it is impractical to probe all full nodes. At this time we consider a simple scheme of maintaining an address book of known full nodes from which a small subset (e.g., 4) are chosen initially to communicate with. More involved book keeping with probabilistic guarantees can be considered at later stages of the project.

The lite client maintains a simple address book  [[lightclient]]
containing addresses of full nodes that it can pick as primary and
secondaries.


### Informal Problem statement

> I put tags to informal problem statements as there is no sequential
> secification.

The following requirements are operational in that they describe how things
should be done, rather than what should be done. They capture the intuition
after the ADR [[lightclient]] had been written. However, they do not constitute
temporal logic verification conditions. For those, see [LCD-VC*] below.


#### **[LCD-IP-Q]**

Whenever the light client verifier adds a new pair
*(p,h)* containing the primary *p* and a header *h* to *State*, the
failure detector should query the secondaries by calling `Commit` remotely.


#### **[LCD-IP-RespOK]**

If a header *h'*, returned by the secondary *s*, is
equal to *h* we add *(s,h)* to state.

*Remark:* This information might later be useful in case we find a
problem when we get another header for this height from a different secondary.


#### **[LCD-IP-RespBad]**

Otherwise, that is, if *h'* returned by *s* is
different from *h*, we analyze the situation. If the failure detector
can prove a fork on the main chain by performing the bisection protocol with *s*, it stops the
light client and submits evidence.


#### **[LCD-IP-PEERSET]**

Whenever the failure detector observes misbehavior of a full node from
the set of Secondaries it should be replaced by a fresh full node. (A full node
that has not been primary or secondary before)



## Assumptions/Incentives/Environment

It is not in the interest of faulty full nodes to talk to the failure detector as long as the failure detector is connected to at least one correct full node. This would only increase the likelihood of misbehavior being detected. Also we cannot punish them easily (cheaply). The absence of a response need not be the fault of the full node. Also, a faulty failure detector could wrongly accuse correct full nodes.

Correct full nodes have the incentive to respond, because the failure detector may help them to understand whether their header is a good one. We can thus base liveness arguments of the failure detector on the assumptions that correct full nodes reliably talk to us.


**Assumptions**

#### **[LCD-A-CorrFull]**

At all times there is at least one correct full
node among the primary and the secondary.

*Remark:* Perhaps [LCD-A-CorrFull] is not needed in the end because
the verification conditions [LCD-VC-...] have preconditions on specific
cases where primary and/or secondaries are faulty.

#### **[LCD-A-RelComm]**

Communication between the failure detector and a correct full node is reliable and bounded in time.


## Problem statement

The failure detector gets as input a header at height *h* and
queries the secondaries for their headers. Eventually, the failure
detector should
decide
  - whether to report evidence for height *h*
  - whether to stop operation at height *h*

The failure detector should satisfy the following temporal formulas  

#### **[LCD-VC-INV]**

If there is no fork at height *h*, and the primary
and the secondaries are correct, then the failure detector should
never output evidence for height *h* and should not stop at height *h*.


#### **[LCD-VC-INV-DONT-STOP]**

If there is no fork at height *h*, and
 the primary is correct, then the failure detector should never stop
 at height *h*.


#### **[LCD-VC-LIFE-DONT-STOP]**

If there is no fork at height *h*, and
 the primary is correct, then the failure detector should eventually
 decide to not stop and to not report evidence
 at height *h*.


#### **[LCD-VC-LIFE-FORK]**

If there is a fork (two correct full nodes decided on different blocks for the same height), and
- the user of the lite client requests a header of a height *h* that is affected (within the trusting period), and
- there are two correct full nodes *i* and *j* that are
    - on different branches, and
    - primary or secondary,

then the failure detector eventually outputs evidence for height *h*.

#### **[LCD-VC-LIFE-FLTPRIM]**

If there is no fork on the main chain and if
the verification trusts a header at
height *h* that deviates from the header on the chain (possibly
because the primary is faulty), and there is a correct secondary, then
the failure detector eventually outputs evidence for height *h*.

TODO: Should we consider this case? Can the precondition happen? Can the verification trust a faulty header if there is no fork?

#### **[LCD-REQ-REP]**

If the failure detector observes two conflicting headers for height *h*, it should try to verify both. If both are verified it should report evidence.


## Definitions

- A fixed set of full nodes is provided in the configuration upon
     initialization. Initially this set is partitioned into
    -  one full node that is the *primary* (singleton set),
	-  a set *Secondaries* (of fixed size, e.g., 3)
	-  a set *FullNodes*
- A set *FaultyNodes* of nodes that the light client suspects of being faulty; it is initially empty
- *State*  is a set of pairs *(fn,h)* where header *h* has been received (and possibly verified with) full node *fn*.
- The verifier communicates with the primary [[verification]]. Whenever the verifier successfully verifies a header *h* from the primary *p*, it stores
 *(p,h)*
 in *State*.


## Solution



### Inter Process Communication



For the purpose of this light client specification, we assume that the
     Tendermint Full Node exposes the following functions over
     Tendermint RPC:

```go
func Commit(addr Address, height int64) (SignedHeader, error)
```

- Implementation remark
   - RPC to full node *n* at address *addr*
- Expected precodnition
  - header of `height` exists on blockchain
- Expected postcondition
  - if *n* is correct: Returns a sound signed header of height `height`
  from the blockchain if communication is timely (no timeout)
  - if *n* is faulty: Returns a signed header with arbitrary content
- Error condition
   * if *n* is correct: precondition violated or timeout
   * if *n* is faulty: arbitrary error

----

### Auxiliary Functions (Local)


```go
Add_to_state(addr Address, sh SignedHeader)
```
- Expected postcondition
   - The pair *(addr,sh)* is added to *State*



```go
still_punishable(sh SignedHeader) (Boolean)
```
- Comment: it might make sense to check whether the unbonding period is
  still running although the trusting period is over
  TODO: fix the period that should be checked. Something between
  trusting period and unbonding period?
- Expected postcondition
    - returns true if misbehavior related to *sh* can still be
      punished. Can be approximated by *sh.bfttime + unbondingperiod > now*



```go
Replace_Secondary(addr Address)
```
- Expected precondition
    - *FullNodes* is nonempty
- Expected postcondition
    - addr is moved from *Secondaries* to *FaultyNodes*
    - an address *a* is moved from *FullNodes* to *Secondaries*
- Error condition
    - if precondition is violated

```go
Report_and_Stop(sh)
```
- Comment:
    - This function communicates the existence of a fork to the outside
	- It creates the evidence from its local information:
	     - all headers of height *sh.height*
		   - possibly all the other pairs *(f,h)* from *State* from full
		     nodes *f* that where used to find the fork (the primary,
		     all involved secondaries)
	- It submits this evidence
	- It flags the light client to stop
- Expected Postcondition
    - It "terminates everything". TODO: should this be described in a nicer
  control flow? How should this be escalated to the whole light client?

#### From the verifier

```go
VerifyHeaderAtHeight
```

## Solution

Shared data of the light client
- a pool of full nodes *FullNodes* that have not been contacted before
- peer set called *Secondaries*
- primary
- State



The problem is solved by calling  the function `FailureDetector` with a header that has
just been verified by the verifier as a parameter. *trustedState*
should be "a possibly old"
trusted state to increase the likelihood of detecting a fork.

```go
func FailureDetector(hd Header, trustedState TrustedState)  {
	for i, s range Secondaries {
		sh := Commit(s,hd.height)
		if validateSignedHeaderAndVals(sh,...) fails {
			// sh is malformed (fails basic validation): *s* is
			// faulty. We replace it in the peer set by a different full node
			Replace_Secondary(s)
			// if this fails, we do not have more full node addresses
			// to talk to. Should we ask for more full nodes?
		}
		else {
			if hd == sh {
				// header matches. we do nothing
			}
			else {
			    // [LCD-REQ-REP]
			    // header does not match. there is a situation.
				// we try to verify sh by querying s
				result := VerifyHeaderAtHeight(sh.height, trusted state, s)
				if result = (sh,OK) {
				    // we verified header sh which is conflicting to hd
					// there is a fork on the main blockchain. -> call panic
					// with all the evidence
					Report_and_Stop(sh)
				}
				else if result = (sh,EXPIRED) {
				    // we verified header sh which is conflicting to hd
					// there is a fork on the main
					// blockchain but trusting period expired. -> if still
					// within unbonding period do panic
					if still_punishable(sh) {
						Report_and_Stop(sh)
					}
					else {
						// try to reproduce the fork  with a
						// later trusted state? If we are lucky,
						// VerifyHeaderAtHeight returns with OK
						TODO
					}
				}
				else {
					// s might be faulty or unreachable
					Replace_peer(s)
					// after this Secondaries might be updated: TODO:
					// decide whether this should imply one more
					// loop iteration
				}
			}
		}
	}
}

```
- Comments
    - Correctness is based on that *hd* has been verified by verification.
- Expected precondition
    - trustedState within trustingperiod
	- Secondaries initialized and non-empty
- Expected postcondition
    - satisfies [LCD-VC-INV], [LCD-VC-INV-DONT-STOP],
	[LCD-VC-LIFE-FORK], [LCD-VC-LIFE-FLTPRIM] for height *hd.height*.
	- TODO: perhaps add return values: returns false under the preconditions of [LCD-VC-INV], [LCD-VC-INV-DONT-STOP]
	-  TODO: perhaps add return values: returns true otherwise
	- removes faulty secondary if it reports wrong header
- Error condition
    - fails if precondition is violated




## Correctness arguments

> Proof sketches of why we believe the solution satisfies the problem statement.
Possibly giving inductive invariants that can be used to prove the specifications
of the problem statement

#### Argument for [LCD-VC-INV]

- In this case, `Commit` will always return the header from the blockchain
- hd == sh will always be true. `FailureDetector` does nothing

#### Argument for [LCD-VC-INV-DONT-STOP]

- In this case, *hd* is the one from the blockchain
- As there is no fork, no faulty secondary can create a sequence of
  headers that convince the failure detector.

  TODO: the last point requires pointers to blockchain invariants, and
  that if there is not fork, no sequence of proof can be generated

#### Argument for [LCD-VC-LIVE-DONT-STOP]

TODO

#### Argument for [LCD-VC-LIFE-FORK]

Can be proven under the assumption that TrustedState is choosen before
the fork happened.


#### Argument for [LCD-VC-LIFE-FLTPRIM]

- When called on a correct secondary, `Commit` will return the header
  from the blockchain
-  hd == sh will evaluate to false.
- `VerifyHeaderAtHeight` will

# References

> links to other specifications/ADRs this document refers to

[[block]] Specification of the block data structure.

[[blockchain]] The specification of the Tendermint blockchain. Tags refering to
this specification are labeled [TMBC-*].

[[verification]] The specification of the light client verification.

[[lightclient]] The light client ADR [77d2651 on Dec 27, 2019].

[TMBC-FM-2THIRDS-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#**[TMBC-FM-2THIRDS-link]**:


[block]: https://github.com/tendermint/spec/blob/master/spec/blockchain/blockchain.md

[blockchain]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md

[lightclient]: https://github.com/interchainio/tendermint-rs/blob/e2cb9aca0b95430fca2eac154edddc9588038982/docs/architecture/adr-002-lite-client.md

[verification]: https://github.com/informalsystems/VDD/blob/master/liteclient/failuredetector.md
