**VDD example for high-level English spec** 

TODO: check that reliable communication is defined properly

TODO: authentication

**concentrates on form rather on content, for now**




# Core Verification

> Rough outline of what the component is doing and why. 2-3 paragraphs

The light client implements a read operation of a [header][TMBC-HEADER-link] from the [blockchain][TMBC-SEQ-link], by communicating with full nodes. 
As some full nodes may be faulty, this functionality must be implemented in a 
fault-tolerant way.

For the purpose of this specification, we assume that the blockchain is a list of headers, rather than a
list of blocks, by [**[TMBC-HEADER]**][TMBC-HEADER-link].

In the Tendermint blockchain, the validator set may change with every new block. 
The staking and unbonding mechanism induces a [security model][TMBC-FM-2THIRDS-link]: 
starting at time *Time* of the block, more than two-thirds of the next 
validators of a new block are correct for the duration of *TrustedPeriod*.
The fault-tolerant read operation is designed for this security model.

The challenge addressed here is that the user might have a block of
height *h1* and needs to read the block of height *h2* greater than *h1*. 
Checking all headers of heights from *h1* to *h2* might be too costly (e.g.,
in terms of energy for mobile devices). 
This specification tries to reduce the number of intermediate blocks that need to 
be checked, by exploiting the guarantees provided by the security model 
mentioned above.

# Part I - External View

## Context of this document

> mention other components and/or specifications that are relevant for this
spec. Possible interactions, possible use cases, etc.

> should give the reader the understanding in what environment this component
will be used.


In this document we specify the light client verification component, called *Verifier*.
The *Verifier* communicates a full node. 
As full nodes may be faulty, the light client has to check whether
the header it receives coincides with the one generated by Tendermint consensus. 
The central features used in this specification are:

 - Tendermint headers extensively use digital signatures 
 and hashes to prove that a block was generated and signed by the validator nodes. 
 The latter is captured by the following invariants: [**[TMBC-INV-SIGN]**][TMBC-INV-SIGN-link] and [**[TMBC-INV-VALID]**][TMBC-INV-VALID-link].

 - the Tendermint [security model][TMBC-FM-2THIRDS-link] guarantees that there is a set of full 
 nodes that represent more than two-thirds of the voting power in the *NextValidators* set, such that the full nodes in this set are correct from 
 the time a block is generated until the trusting period has passed.


 

## Informal Problem statement


Given a height *h* as an input, the *Verifier* stores a header of
height *h* locally. 
This header is generated by Tendermint consensus according to [**[TMBC-SEQ]**][TMBC-SEQ-link].



## Sequential Problem statement

#### **[LCV-Seq-Live]**: 
The *Verifier* gets as input a height *h*, and eventually stores the header of height *h* of the blockchain [**[TMBC-SEQ]**][TMBC-SEQ-link].

#### **[LCV-Seq-Inv]**:
The *Verifier* never stores a header which is not in the blockchain.


# Part II - Protocol view

## Environment/Assumptions/Incentives


> Introduce distributed aspects

> Timing and correctness assumptions. Possibly with justification that the
assumptions make sense, e.g., it is in the interest of a full node to behave
correctly

The light client *Verifier* communicates with a full node of a Tendermint blockchain. 
A full node satisfies the following properties:
[**[TMBC-CorrFull]**][TMBC-CorrFull-link], 
[**[TMBC-Sign]**][TMBC-Sign-link], and
[**[TMBC-FaultyFull]**][TMBC-FaultyFull-link].

### Incentives

Faulty full nodes may benefit from lying to the light client, by making the
light client accept a block that deviates (e.g., contains additional 
transactions) from the one generated by Tendermint consensus. 
Users using the light client might be harmed by accepting a forged header.

The [failure detector][failuredetector] of the light client may help the correct full nodes to understand whether their header is a good one. 
Hence, in combination with the light client failure detector, the correct full nodes have the incentive to respond.
We can thus base liveness arguments on the assumption that correct full nodes reliably talk to the light client.



### Assumptions

#### **[LCV-A-Primary]**:
The verifier communicates with a full node called *primary*. No assumption is made about the full node (it may be correct or faulty).

#### **[LCV-A-Comm]**:
Communication between the light client and a correct full node is reliable and bounded in time.

#### **[LCV-A-TFM]**:
The Tendermint blockchain satisfies the Tendermint failure model [**[TMBC-FM-2THIRDS]**][TMBC-FM-2THIRDS-link].

#### **[LCV-A-LCC]**:
The light client is following the protocol (it is correct).

## Distributed Problem Statement

> safety specifications / invariants in English


> liveness specifications in English. Possibly with timing/fairness requirements:
e.g., if the component is connected to a correct full node and communication is
reliable and timely, then something good happens eventually.

> should have clear formalization in temporal logic.

### Design choices

#### **[LCV-D-State]**:
The light client has a local data structure called *State* that contains headers.

#### **[LCV-D-Primary]**:
The light client has a local variable *primary* that contains the Address (ID) of a full node.

#### **[LCV-D-State-Init]**:
State is initialized with *inithead* that was correctly generated by the Tendermint consensus.

### Temporal Properties

#### **[LCV-VC-Inv]**:
It is always the case that every header in *State* was generated by an instance of Tendermint consensus.

#### **[LCV-VC-Live]**:
From time to time, a new instance of the verifier is called with a height *h*. Each instance must eventually terminate. The instance adds a header *hd* with height *h* to *State* if

  - the *primary* is correct
  - *State* contains a header whose age is less than the trusting period.

*Remark*: These definitions imply that if *primary* is faulty, a header may or may not be added to *State*. In any case, [**[LCV-VC-Inv]**](#lcv-vc-inv) must hold.

*Remark*: The invariant [**[LCV-VC-Inv]**](#lcv-vc-inv) and the liveness requirement [**[LCV-VC-Live]**](#lcv-vc-live)
allow that headers are added to *State* whose height was not passed
to the verifier (e.g., intermediate headers used in bisection; see below).

*Remark*: In liveness [**[LCV-VC-Live]**](#lcv-vc-live) we use "eventually", while in practice
the header *hd* should be added to *State* before the *trustingPeriod* expires, starting from *hd.Time*.

### Solving the sequential specification

This specification provides a partial solution to the sequential specification.
The *Verifier* solves the invariant of the sequential part

[**[LCV-VC-Inv]**](#lcv-vc-inv) => [**[LCV-Seq-Inv]**](#lcv-seq-inv)

In the case the primary is correct, and there is a recent header in *State*, the verifier satisfies the liveness requirements.

/\ "correct primary"  \
/\ \E TrustedState in State. TrustedState.SignedHeader.Header.Time > now - *trustingPeriod* \
/\ [**[LCV-A-Comm]**](#lcv-a-comm) /\ [**[TMBC-CorrFull]**][TMBC-CorrFull-link] /\ [**[LCV-VC-Live]**](#lcv-vc-live)  \
       => [**[LCV-Seq-Live]**](#lcv-seq-live)


## Definitions
> In this section we become more concrete, with basic data types,

> some math that allows to write specifications and pseudo code solution below.
Some variables, etc.

### Data structures

(TODO: Should the data structures be defined here? Or in blockchain.md?) \
TODO: High level explanations of data structures? \
TODO: *State* is missing?

In the following, only the details of the data structures needed for this specification are given.

 ```go
type TrustedState {
    SignedHeader   SignedHeader
    ValidatorSet   ValidatorSet
}
```
A `TrustedState` is a data stucture that is used to store data about 
correct headers (defined below) in the *State* of the light client. 
It has the following fields:
  - `SignedHeader`, a [signed header](fullnode-data-structures) 
  - `ValidatorSet`, a [validator set](blockchain-validator-set)

`---` 

#### **[LCV-CORRECT-SIGNED-HEADER]**
A signed header *sh* of height *h* is correct, if it coincides with the header at height *h* on the blockchain, and:
 - if the `Commit` of *sh* equals to the `LastCommit` of height *h+1* (canonic commit), or
 - if the `Commit` of *sh* contains signatures of validators of height *h* that represent more than two-thirds of the voting power at height *h*.


### Auxiliary Functions (Local)


TODO: should this be here? \
We assume the following auxiliary functions:
```go
func validateSignedHeaderAndVals(sh SignedHeader, 
                                 vs ValidatorSet,
                                 nextVs ValidatorSet) error
```
- Implementation remark
   - Local auxiliary function
- Expected precondition
   - The signed header `sh` and the validator sets `vs, nextVs` are consistent
- Expected postcondition
   - Returns `nil` if the precondition holds
- Error condition
   - precondition violated

`---`

## Solution

> Basic data structures. Simplified, so that we can focus on the distributed
algorithm here. If existing: link to Tendermint data structures, and mentioned
if details were omitted.

> Pseudo code of the solution

The light client verifier has the following configuration parameters:
- *trustThreshold*: a float. Can be used if correctness should not be based on more voting power and 1/3.
- *trustingPeriod*: a time duration [**[TMBC-TIME_PARAMS]**](TMBC-TIME_PARAMS-link).
- *clockDrift*: a time duration. Correction parameter dealing with only approximately synchronized clocks.



We start by presenting the function `VerifyHeaderAtHeight`. 
This function implements the problem statement and is used in
[**[LCV-VC-Live]**](#lcv-vc-live). 

The function `VerifyHeaderAtHeight` checks timestamps, and in case these preliminary checks go through, it calls bisection, by calling the function `VerifyBisection`.
The function `VerifyBisection` implements
the recursive logic for checking whether it is possible to build a trust
relationship between `trustedState` and untrusted header at `untrustedHeight`.

`---`
#### **[LCV-TState]**: 

`VerifyHeaderAtHeight` is called with `trustedState`, whose header is the header that 
has maximal height in *State*, and the address *addr* of the primary.



```go
func VerifyHeaderAtHeight(untrustedHeight int64,
                          trustedState TrustedState,
			              addr Address) (TrustedState, error)
```
- Implementation remark
  - *startTime* and *endTime* are the local system time right after
  invocation of `VerifyHeaderAtHeight` and right before the function returns, respectively.
- Expected precondition
  - The field `Time` of the signed header of `trustedState` is within *trustingPeriod* from *startTime*
- Expected postcondition: 
  - Returns `(trustedState, OK)` under [**[FN-LuckyCase]**](FN-LuckyCase-link), 
  if the signed header of `trustedState`:
      - is the header at height `untrustedHeight` of the blockchain, and 
      - was generated within *trustingPeriod* from *endTime*
  - Returns `(trustedState, EXPIRED)` under [**[FN-LuckyCase]**](FN-LuckyCase-link), if
  the signed header of `trustedState`:
      - is the header at height `untrustedHeight` of the blockchain, and 
      - was generated after *endTime - trustingPeriod* 
- Error conditions
  - precondition violated 
  - [**[FN-LuckyCase]**](FN-LuckyCase-link) does not hold
  - [**[FN-ManifestFaulty]**](FN-ManifestFaulty-link) holds
  


#### **[LCV-INTF]**:
*State* is supposed to be maintained outside of this specification. When 
`VerifyHeaderAtHeight` is called, the signed header of the `trustedState` passed as input is in *State*. When the function returns a `TrustedState`, its signed header is added to *State*.

`---`
`VerifyBisection` is used to get a trusted state, whose signed header has height `untrustedHeight` in the blockchain. 
To do so, `VerifyBisection` first downloads the necessary information
from the *primary*, by calling `QueryPrimary`.
This information includes a signed header `sh`, and two validator sets `vs, nextVs`.
The result of `QueryPrimary`, together with the `trustedState`, is passed as input
to the function `VerifySingle`.
If there are no errors, `VerifySingle` returns a new trusted state.
In `VerifyBisection`, either the new trusted state obtained as result of `VerifySingle` is returned, 
or a new signed header is computed recursively. 

We give the pseudocode of `VerifyBisection` below, as well as the specifications
of the functions called by it.

```go
func VerifyBisection(untrustedHeight int64,
                     trustedState TrustedState,
		             addr Address
                     now Time
		     ) (TrustedState, error) {

  sh, vs, nextVs, err := QueryPrimary(addr,untrustedHeight)
  if err == nil {
    newTrustedState, err := VerifySingle(sh, vs, nextVs, trustedState)
    if err == nil {
      return newTrustedState 
    } else {
      compute pivot
      newTrustedState := VerifyBisection(pivot, trustedState, now)
      return VerifyBisection(untrustedHeight, newTrustedState, now)
      }
  }
}
```
- Expected precondition
  - the field `Time` of the signed header of `trustedState` is within *trustingPeriod* from `now`
- Expected postcondition
  - Returns a trusted state whose header is the header at height `untrustedHeight` from the blockchain, if [**[FN-LuckyCase]**](FN-LuckyCase-link) holds, and if the field `Time` of the header of the returned trusted state is greater than `now + clockDrift`     
- Error conditions 
  - violated precondition 
  - [**[FN-LuckyCase]**](FN-LuckyCase-link) does not hold
  - the header lies in the future (**TODO:** Check with Zarko)

`---`
`QueryPrimary` is called by `VerifyBisection`, and it is used to gather information from a
full node at address `addr`.
```go
func QueryPrimary(addr Address, 
                  untrustedHeight int64) 
                  (SignedHeader,  ValidatorSet, ValidatorSet, error)
```
-  Implementation remark
   - Used to communicate with a full node *n* at address *addr* via RPCs `Commit` and `Validators` 
   - The only function that makes external calls!
- Expected precondition
  - true
- Expected postcondition: 
  - If *n* is correct and there is no error in the RPC to *n*: Returns the following data:
    - `SignedHeader` of height `untrustedHeight`, 
    - `ValidatorSet` of height `untrustedHeight`, 
    - `ValidatorSet` of height `untrustedHeight + 1` 
    - `error`, in this case `nil`
  - If *n* is faulty or there is an error in the RPC to *n*: `error != nil`
  - The field time of the returned signed header is smaller than `now + clockDrift`
- Error conditions
  - precondition violated
  - error in RPC to *n*

*Remark*: Observe that the error conditions includes "error in RPC to *n*" but
*not* [**[FN-LuckyCase]**](FN-LuckyCase-link).
A faulty primary might return arbitrary values, without
forcing the function to report an error.

`---`
If `QueryPrimary` returns without error, `VerifyBisection` calls `VerifySingle`.

```go
func VerifySingle(untrustedSh SignedHeader,
                  untrustedVs ValidatorSet,
                  untrustedNextVs ValidatorSet,
                  trustedState TrustedState) (TrustedState, error)
```

- Implementation remarks:
     - This function does not make external RPC calls to the full node; the whole logic is
based on the local (given) state. 
- Expected precondition:
   - the field `Time` of the untrusted signed header `untrustedSh` is greater than `now + clockDrift` 
   - the signed header of the trusted state was generated within the *trustingPeriod*
   - the height and `Time` of the signed header of the trusted state are smaller than the height and 
  `Time` of the untrusted signed header `untrustedSh`, respectively
   - the untrusted signed header `untrustedSh` and the untrusted validator sets `untrustedVs`, 
  `untrustedNextVs` are consistent
   - if the untrusted signed header `unstrustedSh` is the immediate successor of 
  the signed header of the trusted state `trustedState`, then it holds that 
  the next validator set of the signed header of the `trustedState` is equal to the untrusted 
  validator set `untrustedVs`, and moreover, more than two-thirds of the validators 
  signed
- Expected postcondition: 
    - Returns a trusted state if:
        - the untrusted signed header `untrustedSh` is the immediate successor of the signed header 
    of the trusted state `trustedState`, or
        - the untrusted signed header `untrustedSh` is a successor of
        the signed header of the trusted state `trustedState` and the validators that have more than *max(1/3,trustThreshold)* of voting power in the trusted state `trustedState` signed the untrusted signed header `untrustedSh`
- Error condition: 
   - precondition violated
   - the untrusted signed header `untrustedSh` is not a successor of the signed header of the trusted state `trustedState`


If `VerifySingle` is successful, it returns a `TrustedState` to `VerifyBisection` which in turn also returns this `TrustedState`. Otherwise (and there is no fatal error), `VerifyBisection` computes a pivot height between the height of the signed header of the trusted state `trustedState` and the height `untrustedHeight`, and calls itself recursively.

`---`



## Correctness arguments

> Proof sketches of why we believe the solution satisfies the specifications.
Possibly giving inductive invariants that can be used to prove the specifications
>Link to Part I

**TO BE ARGUED**

### Why the protocol implements the distributed spec

> distributed algorithm correctness proof comes here.


# References

[[block]] Specification of the block data structure. 

[[blockchain]] The specification of the Tendermint blockchain. Tags refering to this specification are labeled [TMBC-*].

[[failuredetector]] The specification of the light client failure detector.

[[fullnode]] Specification of the full node API

[[lightclient]] The light client ADR [77d2651 on Dec 27, 2019].


[block]: https://github.com/tendermint/spec/blob/master/spec/blockchain/blockchain.md
[blockchain]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md
[TMBC-HEADER-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-header
[TMBC-SEQ-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-seq
[TMBC-CorrFull-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-corrfull
[TMBC-Sign-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-sign
[TMBC-FaultyFull-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-faultyfull
[TMBC-TIME_PARAMS-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-time_params
[TMBC-FM-2THIRDS-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-fm-2thirds
[TMBC-INV-SIGN-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-inv-sign
[TMBC-INV-VALID-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-inv-valid

[LCV-VC-LIVE-link]: https://github.com/informalsystems/VDD/tree/master/lightclient/verification.md#lcv-vc-live

[lightclient]: https://github.com/interchainio/tendermint-rs/blob/e2cb9aca0b95430fca2eac154edddc9588038982/docs/architecture/adr-002-lite-client.md
[failuredetector]: https://github.com/informalsystems/VDD/blob/master/liteclient/failuredetector.md
[fullnode]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md

[FN-LuckyCase-link]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md#fn-luckycase

[blockchain-validator-set]: https://github.com/tendermint/spec/blob/master/spec/blockchain/blockchain.md#data-structures
[fullnode-data-structures]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md#data-structures

[FN-ManifestFaulty-link]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md#fn-manifestfaulty
