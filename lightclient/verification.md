**VDD example for high-level English spec**


**concentrates on form rather on content, for now**

# Core Verification

> Rough outline of what the component is doing and why. 2-3 paragraphs

The light client implements a read operation of a [header][TMBC-HEADER-link] from the [blockchain][TMBC-SEQ-link], by communicating with full nodes. 
As some full nodes may be faulty, this functionality must be implemented in a 
fault-tolerant way.

(TODO: add link to remark about blocks/headers)

In the Tendermint blockchain, the validator set may change with every new block. 
The staking and unbonding mechanism induces a [security model][TMBC-FM-2THIRDS-link]: 
starting at time _bfttime_ of the block, more than two-thirds of the next 
validators of a new block are correct for the duration of _TrustedPeriod_.
The fault-tolerant read operation is designed for this security model.

The challenge addressed here is that the user might have a block of
height _h1_ and needs to read the block of height _h2_ greater than _h1_. 
Checking all headers of heights from _h1_ to _h2_ might be too costly (e.g.,
in terms of energy for mobile devices). 
This specification tries to reduce the number of intermediate blocks that need to 
be checked, by exploiting the guarantees provided by the security model 
mentioned above.

# Part I - External View

## Context of this document

> mention other components and/or specifications that are relevant for this
spec. Possible interactions, possible use cases, etc.

> should give the reader the understanding in what environment this component
will be used.


In this document we specify the light client verification component, called _Verifier_.
The _Verifier_ communicates a full node. 
As full nodes may be faulty, the light client has to check whether
the header it receives coincides with the one generated by Tendermint consensus. 
The central features used in this specification are:

 - Tendermint headers extensively use digital signatures 
 and hashes to prove that a block was generated and signed by the validator nodes. 
 The latter is captured by the following invariants: [**[TMBC-INV-SIGN]**][TMBC-INV-SIGN-link] and [**[TMBC-INV-VALID]**][TMBC-INV-VALID-link].

 - the Tendermint [security model][TMBC-FM-2THIRDS-link] guarantees that there is a set of full 
 nodes that represent more than two-thirds of the voting power in the _NextValidators_ set, such that the full nodes in this set are correct from 
 the time a block is generated until the trusting period has passed.


 

## Informal Problem statement


Given a height *h* as an input, the _Verifier_ stores a header of
height *h* locally. 
This header is generated by Tendermint consensus according to [**[TMBC-SEQ]**][TMBC-SEQ-link].



## Sequential Problem statement

#### **[LCV-Seq-Live]**: 
The _Verifier_ gets as input a height _h_, and eventually stores the header of height _h_ of the blockchain [**[TMBC-SEQ]**][TMBC-SEQ-link].

#### **[LCV-Seq-Inv]**:
The _Verifier_ never stores a header which is not in the blockchain.


# Part II - Protocol view

## Environment/Assumptions/Incentives


> Introduce distributed aspects

> Timing and correctness assumptions. Possibly with justification that the
assumptions make sense, e.g., it is in the interest of a full node to behave
correctly

The light client _Verifier_ communicates with a full node of a Tendermint blockchain. 
A full node satisfies the following properties:
[**[TMBC-CorrFull]**][TMBC-CorrFull-link], 
[**[TMBC-Sign]**][TMBC-Sign-link], and
[**[TMBC-FaultyFull]**][TMBC-FaultyFull-link].

### Incentives

Faulty full nodes may benefit from lying to the light client, by making the
light client accept a block that deviates (e.g., contains additional 
transactions) from the one generated by Tendermint consensus. 
Users using the light client might be harmed by accepting a forged header.

The [failure detector][failuredetector] of the light client may help the correct full nodes to understand whether their header is a good one. 
Hence, in combination with the light client failure detector, the correct full nodes have the incentive to respond.
We can thus base liveness arguments on the assumption that correct full nodes reliably talk to the light client.



### Assumptions

#### **[LCV-A-Primary]**:
The verifier communicates with a full node called _primary_. No assumption is made about the full node (it may be correct or faulty).

#### **[LCV-A-Comm]**:
Communication between the light client and a correct full node is reliable and bounded in time.

#### **[LCV-A-TFM]**:
The Tendermint blockchain satisfies the Tendermint failure model [**[TMBC-FM-2THIRDS]**][TMBC-FM-2THIRDS-link].

#### **[LCV-A-LCC]**:
The light client is following the protocol (it is correct).

## Distributed Problem Statement

> safety specifications / invariants in English


> liveness specifications in English. Possibly with timing/fairness requirements:
e.g., if the component is connected to a correct full node and communication is
reliable and timely, then something good happens eventually.

> should have clear formalization in temporal logic.

### Design choices

#### **[LCV-D-State]**:
The light client has a local data structure called _State_ that contains headers.

#### **[LCV-D-State-Init]**:
State is initialized with _inithead_ that was correctly generated by the Tendermint consensus.

### Temporal Properties

#### **[LCV-VC-Inv]**:
It is always the case that every header in _State_ was generated by an instance of Tendermint consensus.

#### **[LCV-VC-Live]**:
From time to time, a new instance of the verifier is called with a height _h_. Each instance must eventually terminate. The instance adds a header _hd_ with height _h_ to _State_ if

  - the _primary_ is correct

  - _State_ contains a header whose age is less than the trusting period.

_Remark_: The definitions imply that if _primary_ is faulty a header may or may not be added to _State_. In any case, [**[LCV-VC-Inv]**](#**[LCV-VC-Inv]**:) must hold.

_Remark_: The invariant [**[LCV-VC-Inv]**](#**[LCV-VC-Inv]**:) and the liveness requirement [**[LCV-VC-Live]**](#**[LCV-VC-Live]**:)
allow that headers are added to _State_ whose height was not passed
to the verifier (e.g., intermediate headers used in bisection; see below).

_Remark_: In liveness [**[LCV-VC-Live]**](#**[LCV-VC-Live]**:) we use "eventually", while in practice
the header _hd_ should be added to _State_ before the _trustingPeriod_ expires, starting from _hd.bfttime_.

### Solving the sequential specification

This specification provides a partial solution to the sequential specification.
The _Verifier_ solves the invariant of the sequential part

[**[LCV-VC-Inv]**](#**[LCV-VC-Inv]**:) => [**[LCV-Seq-Inv]**](#**[LCV-Seq-Inv]**:)

In the case the primary is correct, and there is a recent header in _State_, the verifier satisfies the liveness requirements.

/\ "correct primary"  \
/\ \E TrustedState in State. TrustedState.SignedHeader.Header.Time > now - _trustingPeriod_ \
/\ [**[LCV-A-Comm]**](#**[LCV-A-Comm]**:) /\ [**[TMBC-CorrFull]**][TMBC-CorrFull-link] /\ [**[LCV-VC-Live]**](#**[LCV-VC-Live]**:)  \
       => [**[LCV-Seq-Live]**](#**[LCV-Seq-Live]**)


## Definitions
> In this section we become more concrete, with basic data types,

> some math that allows to write specifications and pseudo code solution below.
Some variables, etc.

### Data structures

(TODO: Should the data structures be defined here? Or in blockchain.md?)

In the following, only the details of the data structures needed for this specification are given.

 ```go
   type Header struct {
        Height               int64
        Time                 Time          // the chain time when the header (block) was generated

        LastBlockID          BlockID       // prev block info
        ValidatorsHash       []byte        // hash of the validators for the current block
        NextValidatorsHash   []byte        // hash of the validators for the next block
   }

   type SignedHeader struct {
        Header        Header
        Commit        Commit            // commit for the given header
   }

   type ValidatorSet struct {
        Validators         []Validator
        TotalVotingPower   int64
   }

   type Validator struct {
        Address       Address           // validator address (we assume validator's addresses are unique)
        VotingPower   int64             // validator's voting power
   }

   type TrustedState {
        SignedHeader   SignedHeader
        ValidatorSet   ValidatorSet
   }
 ```

### Inter Process Communication



For the purpose of this light client specification, we assume that the
     Tendermint Full Node exposes the following functions over
     Tendermint RPC:

```go
func Commit(height int64) (SignedHeader, error)
```
- Implementation remark
   - RPC to full node _n_
- Expected precodnition
  - header of `height` exists on blockchain
- Expected postcondition
  - if _n_ is correct: Returns the signed header of height `height`
  from the blockchain if communication is timely (no timeout)
  - if _n_ is faulty: Returns a signed header with arbitrary content
- Error condition
   * if _n_ is correct: precondition violated or timeout
   * if _n_ is faulty: arbitrary error

----


 ```go    
func Validators(height int64) (ValidatorSet, error)
```
- Implementation remark
   - RPC to full node _n_
- Expected precodnition
  - header of `height` exists on blockchain
- Expected postcondition
  - if _n_ is correct: Returns the validator set of height `height`
  from the blockchain if communication is timely (no timeout)
  - if _n_ is faulty: Returns arbitrary validator set
- Error condition
  - if _n_ is correct: precondition violated or timeout 
  - if _n_ is faulty: arbitrary error

----

#### **[LCV-LuckyCase]**:
The primary is correct and no timeout occurs on `Commit` and `Validators`.

(TODO: move to temporal properties?)

---

### Auxiliary Functions (Local)


TODO 
We assume the following auxiliary functions:
```go
    // returns true if the commit is for the header, ie. if it contains
    // the correct hash of the header; otherwise false
    func matchingCommit(header Header, commit Commit) bool

    // returns the set of validators from the given validator set that
    // committed the block (that correctly signed the block)
    // it assumes signature verification so it can be computationally expensive
    func signers(commit Commit, validatorSet ValidatorSet) []Validator

    // returns the voting power the validators in v1 have according to their voting power in set v2
    // it does not assume signature verification
    func votingPowerIn(v1 []Validator, v2 ValidatorSet) int64

    // returns hash of the given validator set
    func hash(v2 ValidatorSet) []byte

    // returns nil if header and validator sets are consistent; otherwise returns error
    func validateSignedHeaderAndVals(signedHeader SignedHeader,
                                     vs ValidatorSet,
                                     nextVs ValidatorSet) error
```




## Solution

> Basic data structures. Simplified, so that we can focus on the distributed
algorithm here. If existing: link to Tendermint data structures, and mentioned
if details were omitted.

> Pseudo code of the solution

Configuration Parameters:
- _trustThreshold float_: Can be used if correctness should not be based on more voting power and 1/3.
- _trustingPeriod Duration_: [**[TMBC-TIME_PARAMS]**][TMBC-TIME_PARAMS-link]
- _clockDrift Duration_: correction parameter dealing with only approximately synchronized clocks.



We start with the function `VerifyHeaderAtHeight` whose call is the one mentioned in
[**[LCV-VC-Live]**](#**[LCV-VC-Live]**:). It implements the problem statement.

#### **[LCV-TState]**: 
`VerifyHeaderAtHeight` is called with trustedState which contains the header in _State_ with maximal height.

---

```go
func VerifyHeaderAtHeight(untrustedHeight int64,
                          trustedState TrustedState,
                          ) (TrustedState, error))
```
- Expected precondition: trustedState within trustingperiod from _starttime_
- Expected postcondition: Returns
    * (header, OK):  under [LCV-LuckyCase] and
                  header is of height
                 untrustedHeightof
                 the blockchain and header within trustingperiod
                 from _endtime_
	* (header, EXPIRED):  under [LCV-LuckyCase]	and
                  header is of height
                 untrustedHeight of
                 the blockchain and header outside trustingperiod
                 from _endtime_	 
- Error: if precondition is violated or if outside of [LCV-LuckyCase]
  (unless outside of lucky case but faulty primary sends correct
  headers; depends on the definition of faulty)

- _starttime_ and _endtime_ are the local system time right after
  invocation and right before return, respectively.

#### **[LCV-INTF]**:
_State_ is supposed to be maintained outside of this specification. When _VerifyHeaderAtHeight_ is called, _trustedState_ is in _State_. When _TrustedState_ is returned it is added to _State_.

`VerifyHeaderAtHeight` checks timestamps, and in case these preliminary checks go through, calls bisection: The function `VerifyBisection` implements
the recursive logic for checking whether it is possible to build a trust
relationship between `trustedState` and untrusted header at `untrustedHeight`.

---

```go
func VerifyBisection(untrustedHeight int64,
                     trustedState TrustedState,
                     now Time) (TrustedState, error) {

  sh, vs1, vs2 := query_primary(untrustedHeight)
  res := VerifySingle(sh, vs1, vs2, trustedState)
  if res == "success" {
    return sh
  } else if res == "could not verify" {
    compute pivot
    newTrustedState := VerifyBisection(pivot, trustedState, now)
    return VerifyBisection(untrustedHeight, newTrustedState, now)
  }
                     }
```
- Expected precondition: trustedState.bfttime within trustingperiod from now
- Expected postcondition:
    Returns header hd of height untrustedHeight from blockchain if
    hd.Time > now + clockDrift under  [LCV-LuckyCase]
- Error: if precondition is violated  or if outside of [LCV-LuckyCase]
 or _something about time is fishy_ (**TODO:** Check with Zarko)

To do so, `VerifyBisection` first downloads the necessary information
from the _primary_ using the following `query_primary`.

---

```go
func query_primary(untrustedHeight int64) (SignedHeader,  ValidatorSet, ValidatorSet)
```
- Communicates with primary via RPCs `Commit`, and `Validators`
- Expected postcondition: Returns the following data,
if there is no error in the RPC to the primary,
   * SignedHeader of height untrustedHeight (called untrustedSh)
   * ValidatorSet of height untrustedHeight (called untrustedVs)
   * ValidatorSet of height untrustedHeight + 1 (called untrustedNextVs)
- Expected postcondition:  hd.Time < now + clockDrift

- Error: on error in RPC to primary or if postcondition is violated

_Remark_: Observe that the  conditions here are  "error in RPC" but
_not_ [LCV-LuckyCase]
in this case. A faulty primary might return arbitrary values, without
forcing the function to report an error.


If `query_primary` returns without error, `VerifyBisection` calls `VerifySingle`.

---


```go
func verifySingle(untrustedSh SignedHeader,
                  untrustedVs ValidatorSet,
                  untrustedNextVs ValidatorSet,
                  trustedState TrustedState)  error
```
- Expected precondition:
  * untrustedSh.Header.Time > now + clockDrift
  * isWithinTrustedPeriod(trustedState.SignedHeader.Header,
    trustingPeriod, now)
  * trustedState.SignedHeader.Header.Height < untrustedHeader.Height
  * trustedState.SignedHeader.Header.Time < untrustedHeader.Time
  * validateSignedHeaderAndVals(untrustedSh, untrustedVs,
    untrustedNextVs)
  * **[TMBC-SIGN]** (untrustedHeader.Height =
    trustedState.SignedHeader.Header.Height + 1) ->
    ((trustedState.SignedHeader.Header.NextValidatorsHash =
    untrustedHeader.ValidatorsHash) AND "more than 2/3 signed")
- Expected postcondition: Returns
  * "success" if untrustedHeader.Height =
              trustedState.SignedHeader.Header.Height + 1
  * "success" if untrustedHeader.Height >
              trustedState.SignedHeader.Header.Height + 1 and
             "more than max(1/3,trustThreshold) of voting power in trusted signed untrusted"
  * "could not verify" otherwise
- Error: if precondition is violated



*Remark:* This function is not making external (RPC) calls to the full node; the whole logic is
based on the local (given) state. Only `query_primary` makes external calls!

If `VerifySingle` is successful, it returns _TrustedState_ to `VerifyBisection` which in turn also returns _TrustedState_. Otherwise (and there is no fatal error), `VerifyBisection` computes a pivot height between _trustedState.height_ and _untrustedHeight_, and goes into recursion.

---



## Correctness arguments

> Proof sketches of why we believe the solution satisfies the specifications.
Possibly giving inductive invariants that can be used to prove the specifications
>Link to Part I

**TO BE ARGUED**

### Why the protocol implements the distributed spec

> distributed algorithm correctness proof comes here.


# References

[[block]] Specification of the block data structure. 

[[blockchain]] The specification of the Tendermint blockchain. Tags refering to this specification are labeled [TMBC-*].

[[failuredetector]] The specification of the light client failure detector.

[[lightclient]] The light client ADR [77d2651 on Dec 27, 2019].


[block]: https://github.com/tendermint/spec/blob/master/spec/blockchain/blockchain.md
[blockchain]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md
[TMBC-HEADER-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#**[TMBC-HEADER]**:
[TMBC-SEQ-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#**[TMBC-SEQ]**:
[TMBC-CorrFull-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#**[TMBC-CorrFull]**
[TMBC-Sign-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#**[TMBC-Sign]**
[TMBC-FaultyFull-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#**[TMBC-FaultyFull]**
[TMBC-TIME_PARAMS-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#**[TMBC-TIME_PARAMS]**:
[TMBC-FM-2THIRDS-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#**[TMBC-FM-2THIRDS-link]**:
[TMBC-INV-SIGN-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#**[TMBC-INV-SIGN]**:
[TMBC-INV-VALID-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#**[TMBC-INV-VALID]**:

[lightclient]: https://github.com/interchainio/tendermint-rs/blob/e2cb9aca0b95430fca2eac154edddc9588038982/docs/architecture/adr-002-lite-client.md
[failuredetector]: https://github.com/informalsystems/VDD/blob/master/liteclient/failuredetector.md