**VDD example for high-level English spec**


**concentrates on form rather on content, for now**

# Core Verification

> Rough outline of what the component is doing and why. 2-3 paragraphs

The lite client implements a read operation of a block (header) from the
blockchain. It does so by communicating with full nodes. As full nodes
may be faulty, this functionality must be implemented in a fault-tolerant
way.

In Tendermint blockchains, the validator
set may change with every new block. The staking and unbonding mechanism induces a security model: more than 2/3 of the next validators of a new block are correct for _TrustedPeriod_ starting
  with _bfttime_ of the block. The fault-tolerant read operation
  is designed for this dynamic fault model.

The challenge addressed here is that the user might have a block of
height _h1_ and needs to read the block of height _h2_. Checking all headers of heights from _h1_ to _h2_ might be too costly (e.g., in terms of energy for mobile devices). This spec tries to reduce
then number of intermediate blocks that need to be checked, by exploiting the guarantees provided by the security model mentioned above.


# Part I - External View

## Context of this document

> mention other components and/or specifications that are relevant for this
spec. Possible interactions, possible use cases, etc.

> should give the reader the understanding in what environment this component
will be used.


In this document we specify the communication of the lite client verification component with
a full node. As full nodes may be faulty, the lite client has to check whether
the header it receives are the ones generated by Tendermint consensus. The
central features used in this specification are:

 - Tendermint blocks
(and headers) extensively use digital signatures and hashes to prove that a
block is OK, e.g., signed by validators that represent more than 2/3 of the voting power.

 - the Tendermint failure model  guarantees that there is a set of full nodes
 that represent more than 2/3 of the
 voting power in the "next validators" set
 are correct from the time a block is generated until the trusting period is
 passed.

 This document refers to

   - some specification of the blockchain "Tendermint consensus" with full nodes, validators, tendermint failure model, trusting trustingPeriod  
   at ../blockchain/blockchain.md. Tags refering to this spec are labeled
   [TMBC-?]

   - some specification what constitutes are valid block. what can be checked without writing code that does the checks. hashes, signatures, etc.
https://github.com/tendermint/spec/blob/master/spec/blockchain/blockchain.md

   - the lite client ADR [77d2651 on Dec 27, 2019]
 https://github.com/interchainio/tendermint-rs/blob/e2cb9aca0b95430fca2eac154edddc9588038982/docs/architecture/adr-002-lite-client.md


## Informal Problem statement


Given a height *h* as an input, the lite client locally stores the header of
height *h* that is generated by Tendermint consensus according to [TMBC-SEQ].



## Sequential Problem statement



**[LCV-Seq-Live]** The verifier gets as input a height _h_, and eventually stores the header of height _h_ of the blockchain [TMBC-SEQ].

**[LCV-Seq-Inv]** The verifier never stores a header which is not in the blockchain.

# Part II - Protocol view

## Environment/Assumptions/Incentives


> Introduce distributed aspects

> Timing and correctness assumptions. Possibly with justification that the
assumptions make sense, e.g., it is in the interest of a full node to behave
correctly

Lite client verification communicates with a full node of a Tendermint block chain.

**[TFM-CorrFull]** Every correct Tendermint full node locally stores a prefix of the current list of headers from [TMBC].

**[TFM-FaultyFull]** No assumption is made about the behavior of faulty full nodes; they may be Byzantine.

**[TFM-Sign]** Signatures and hashes cannot be broken.

### Incentives

Faulty full nodes may benefit from lying to the lite client, e.g., if
the lite client accepts a block that deviates (e.g., contains
  additional transactions) from the one generated
by Tendermint consensus. Users using the lite client might be harmed
by accepting a forged header.

In combination with the lite client failure detector,
correct full nodes have the incentive to respond, because the failure detector of the lite client may help them to understand whether their header is a good one. We can thus base liveness arguments on the assumptions that correct full nodes reliably talk to us.



### Assumptions

**[LCV-A-Full]** The verifier communicates with a full node called _primary_. No assumption is made about the full node (it may be correct or faulty).

**[LCV-A-Comm]**  Communication between the lite client and a correct full node is reliable and bounded in time.

**[LCV-A-TFM]** The Tendermint block chain satisfies the Tendermint failure model [TMBC-FM-2THIRDS].

**[LCV-A-LCC]** The lite client is following the protocol (it is correct).

## Distributed Problem Statement

> safety specifications / invariants in English


> liveness specifications in English. Possibly with timing/fairness requirements:
e.g., if the component is connected to a correct full node and communication is
reliable and timely, then something good happens eventually.

> should have clear formalization in temporal logic.

### Design choices

**[LCV-D-State]** The lite client has a local data structure called _State_ that contains headers.

**[LCV-D-State-Init]** Trusted State is initialized with _inithead_ that was correctly generated by the Tendermint consensus.

### Temporal Properties

**[LCV-VC-Inv]** At all times, every header in _State_ was generated by an instance of Tendermint consensus.

**[LCV-VC-Live]**
From time to time, verifier is called with a height _h_. Each instance must eventually terminate. The instance adds a header _hd_ with height _h_ to _State_ if

  - the _primary_ is correct

  - _State_ contains a header whose age is less than the trusting period.

_Remark_: The definitions imply that if _primary_ is faulty a header may or may not be added to _State_. In any case, [LCV-VC-Inv] must hold.

_Remark_: The invariant [LCV-VC-Inv] and liveness requirement [LCV-VC-Live]
allow that headers are added to _State_ whose height was not passed
to the verifier (e.g., intermediate headers used in bisection; see below).

_Remark_: In liveness [LCV-VC-Live]we use "eventually", while in practice _trust(h)_ should be set to true before _h.Header.bfttime + tp_. If not, the block cannot be trusted because it is too old.

### Solving the sequential Specification

This specification provides a partial solution to the sequential specification.
The verifier (this document) solves the invariant of the sequential part

[LCV-VC-Inv] -> [LCV-Seq-Inv]

In the case the primary is correct, and there is a recent header in _State_, the verifier satisfies the liveness requirements.

/\ "correct primary"  \
/\ \Exists TrustedState in State. TrustedState.SignedHeader.Header.Time > now - tp_
/\ [LCV-A-Comm] /\ [TFM-CorrFull] /\ [LCV-VC-Live]  \
       -> [LCV-Seq-Live]


## Definitions
> In this section we become more concrete, with basic data types,

> some math that allows to write specifications and pseudo code solution below.
Some variables, etc.

### Data structures

In the following, only the details of the data structures needed for this specification are given.

 ```go
   type Header struct {
        Height               int64
        Time                 Time          // the chain time when the header (block) was generated

        LastBlockID          BlockID       // prev block info
        ValidatorsHash       []byte        // hash of the validators for the current block
        NextValidatorsHash   []byte        // hash of the validators for the next block
   }

   type SignedHeader struct {
        Header        Header
        Commit        Commit            // commit for the given header
   }

   type ValidatorSet struct {
        Validators         []Validator
        TotalVotingPower   int64
   }

   type Validator struct {
        Address       Address           // validator address (we assume validator's addresses are unique)
        VotingPower   int64             // validator's voting power
   }

   type TrustedState {
        SignedHeader   SignedHeader
        ValidatorSet   ValidatorSet
   }
 ```

### Inter Process Communication



For the purpose of this light client specification, we assume that the
     Tendermint Full Node exposes the following functions over
     Tendermint RPC: 

```go
    // RPC to full node
    // returns signed header: Header with Commit, for the given height
    func Commit(height int64) (SignedHeader, error)
```

- Expected postcondition
   * correct full node -> Returns the signed header of height height
     from the blockchain if communication is timely (no timeout)
   * faulty full node -> Returns arbitrary
- Fails 
   * correct full node ->  height < 0 or height does not exist on blockchain or timeout
   * faulty full node -> arbitrary
		
  


```go
    // returns validator set for the given height
    func Validators(height int64) (ValidatorSet, error)
```
- Expected postcondition
   * correct full node -> Returns the  Validator Set of height height
     from the blockchain if communication is timely (no timeout)
   * faulty full node -> Returns arbitrary
- Fails 
   * correct full node ->  height < 0 or height does not exist on blockchain or timeout
   * faulty full node -> arbitrary



**[LCV-LuckyCase]** All runs where the primary is correct and no
timeout occurs on `Commit` and `Validators`.


### Functions



We assume the following auxiliary functions:
```go
    // returns true if the commit is for the header, ie. if it contains
    // the correct hash of the header; otherwise false
    func matchingCommit(header Header, commit Commit) bool

    // returns the set of validators from the given validator set that
    // committed the block (that correctly signed the block)
    // it assumes signature verification so it can be computationally expensive
    func signers(commit Commit, validatorSet ValidatorSet) []Validator

    // returns the voting power the validators in v1 have according to their voting power in set v2
    // it does not assume signature verification
    func votingPowerIn(v1 []Validator, v2 ValidatorSet) int64

    // returns hash of the given validator set
    func hash(v2 ValidatorSet) []byte
	
    // returns nil if header and validator sets are consistent; otherwise returns error
    func validateSignedHeaderAndVals(signedHeader SignedHeader, 
                                     vs ValidatorSet, 
                                     nextVs ValidatorSet) error
```




## Solution

> Basic data structures. Simplified, so that we can focus on the distributed
algorithm here. If existing: link to Tendermint data structures, and mentioned
if details were omitted.

> Pseudo code of the solution

Configuration Parameters:
- _trustThreshold float_:
- _trustingPeriod Duration_:
- _clockDrift Duration_:


### Solution

This is the signature of the function whose call is mentioned in
[LCV-VC-Live]. It implements the problem statement.

```go
func VerifyHeaderAtHeight(untrustedHeight int64,
                          trustedState TrustedState,
                          ) (TrustedState, error))
```
- Expected precondition: trustedState within trustingperiod from _starttime_
- Expected postcondition: Returns
    * (header, OK): if
                  header of height
                 untrustedHeight and "header within trustingperiod
                 from "endtime" of
                 the blockchain under [LCV-LuckyCase]
	* (header, EXPIRED): if
                  header of height
                 untrustedHeight and "header outside trustingperiod
                 from _endtime_ of
                 the blockchain under [LCV-LuckyCase]		 
- Fails: if precondition is violated or if outside of [LCV-LuckyCase]

- starttime and endtime are the local system time right after
  invocation and right before return, respectively.

**[LCV-INTF]** _State_ is supposed to be maintained outside of this specification. When _VerifyHeaderAtHeight_ is called, _trustedState_ is in _State_. When _TrustedState_ is returned it is added to _State_.

`VerifyHeaderAtHeight` checks timestamps, and in case these preliminary checks go through, calls bisection: The function `VerifyBisection` implements
the recursive logic for checking whether it is possible to build a trust
relationship between `trustedState` and untrusted header at `untrustedHeight`.

```go
func VerifyBisection(untrustedHeight int64,
                     trustedState TrustedState,
                     now Time) (TrustedState, error)
```
- Expected precondition: trustedState.bfttime within trustingperiod from now
- Expected postcondition:
    Returns header hd of height untrustedHeight from blockchain if 
    hd.Time > now + clockDrift under  [LCV-LuckyCase]
- Fails: if precondition is violated  or if outside of [LCV-LuckyCase]
 or _something about time is fishy_

To do so, `VerifyBisection` first downloads the necessary information
from the _primary_:

```go
func query_primary(untrustedHeight int64) (SignedHeader,  ValidatorSet, ValidatorSet)
```
- Communicates with primary via RPCs `Commit`, and `Validators`
- Expected postcondition: Returns the following data, 
if there is no error in the RPC to the primary,
   * SignedHeader of height untrustedHeight (called untrustedSh)
   * ValidatorSet of height untrustedHeight (called untrustedVs)
   * ValidatorSet of height untrustedHeight + 1 (called untrustedNextVs)
- Expected postcondition:  hd.Time < now + clockDrift 
	
- Fails: on error in RPC to primary or if postcondition is violated

_Remark_: Observe that the  conditions here are  "error in RPC" but
_not_ [LCV-LuckyCase]
in this case. A faulty primary might return arbitrary values, without
forcing the function to report an error.


If `query_primary` returns without error, `VerifyBisection` calls `VerifySingle`:


```go
func verifySingle(untrustedSh SignedHeader,
                  untrustedVs ValidatorSet,
                  untrustedNextVs ValidatorSet,
                  trustedState TrustedState)  error
```
- Expected precondition:
  * untrustedSh.Header.Time > now + clockDrift
  * isWithinTrustedPeriod(trustedState.SignedHeader.Header,
    trustingPeriod, now)
  * trustedState.SignedHeader.Header.Height < untrustedHeader.Height	
  * trustedState.SignedHeader.Header.Time < untrustedHeader.Time
  * validateSignedHeaderAndVals(untrustedSh, untrustedVs,
    untrustedNextVs)
  * (untrustedHeader.Height =
    trustedState.SignedHeader.Header.Height + 1) ->
    ((trustedState.SignedHeader.Header.NextValidatorsHash =
    untrustedHeader.ValidatorsHash) AND "more than 2/3 signed")
- Expected postcondition: Returns 
  * "success" if untrustedHeader.Height =
              trustedState.SignedHeader.Header.Height + 1
  * "success" if untrustedHeader.Height >
              trustedState.SignedHeader.Header.Height + 1 and
             "more than max(1/3,trustThreshold) of voting power in trusted signed untrusted"
  * "could not verify" otherwise
- Fails: if precondition is violated



*Remark:* This function is not making external (RPC) calls to the full node; the whole logic is
based on the local (given) state. Only `query_primary` makes external calls!

If `VerifySingle` is successful, it returns _TrustedState_ to `VerifyBisection` which in turn also returns _TrustedState_. Otherwise (and there is no fatal error), `VerifyBisection` computes a pivot height between _trustedState.height_ and _untrustedHeight_, and goes into recursion.




## Correctness arguments

> Proof sketches of why we believe the solution satisfies the specifications.
Possibly giving inductive invariants that can be used to prove the specifications
>Link to Part I



### Why the protocol implements the distributed spec

> distributed algorithm correctness proof comes here.
