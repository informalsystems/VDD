**VDD example for high-level English spec**

**concentrates on form rather on content, for now**

# Core Verification

> Rough outline of what the component is doing and why. 2-3 paragraphs

The lite client implements a read operation of a block (header) from the
blockchain. It does so by communicating with full nodes. As full nodes
may be faulty, this functionality must be implemented in a fault-tolerant
way.

In Tendermint blockchains, the validator
set may change with every new block. The staking and unbonding mechanism induces a security model: more than 2/3 of the next validators of a new block are correct for _TrustedPeriod_ starting
  with _bfttime_ of the block. The fault-tolerant read operation
  is designed for this dynamic fault model.

The challenge addressed here is that the user might have a block of
height _h1_ and needs to read the block of height _h2_. Checking all headers of heights from _h1_ to _h2_ might be too costly (e.g., in terms of energy for mobile devices). This spec tries to reduce
then number of intermediate blocks that need to be checked, by exploiting the guarantees provided by the security model mentioned above.


# Part I - External View

## Context of this document

> mention other components and/or specifications that are relevant for this
spec. Possible interactions, possible use cases, etc.

> should give the reader the understanding in what environment this component
will be used.


In this document we specify the communication of the lite client verification component with
a full node. As full nodes may be faulty, the lite client has to check whether
the header it receives are the ones generated by Tendermint consensus. The
central features used in this specification are:

 - Tendermint blocks
(and headers) extensively use digital signatures and hashes to prove that a
block is OK, e.g., signed by validators that represent more than 2/3 of the voting power.

 - the Tendermint failure model  guarantees that there is a set of full nodes
 that represent more than 2/3 of the
 voting power in the "next validators" set
 are correct from the time a block is generated until the trusting period is
 passed.

 This document refers to

   - some specification of the blockchain "Tendermint consensus" with full nodes, validators, tendermint failure model, trusting trustingPeriod  
   at ../blockchain/blockchain.md. Tags refering to this spec are labeled
   [TMBC-?]

   - some specification what constitutes are valid block. what can be checked without writing code that does the checks. hashes, signatures, etc.
https://github.com/tendermint/spec/blob/master/spec/blockchain/blockchain.md

   - the lite client ADR [77d2651 on Dec 27, 2019]
 https://github.com/interchainio/tendermint-rs/blob/e2cb9aca0b95430fca2eac154edddc9588038982/docs/architecture/adr-002-lite-client.md


## Informal Problem statement


Given a height *h* as an input, the lite client locally stores the header of
height *h* that is generated by Tendermint consensus according to [TMBC-SEQ].



## Sequential Problem statement



**[LCV-Seq-Live]** The verifier gets as input a height _h_, and eventually stores the header of height _h_ of the blockchain [TMBC-SEQ].

**[LCV-Seq-Inv]** The verifier never stores a header which is not in the blockchain.

# Part II - Protocol view

## Environment/Assumptions/Incentives


> Introduce distributed aspects

> Timing and correctness assumptions. Possibly with justification that the
assumptions make sense, e.g., it is in the interest of a full node to behave
correctly

Lite client verification communicates with a full node of a Tendermint block chain.

**[TFM-CorrFull]** Every correct Tendermint full node locally stores a prefix of the current list of headers from [TMBC].

**[TFM-FaultyFull]** No assumption is made about the behavior of faulty full nodes; they may be Byzantine.

**[TFM-Sign]** Signatures and hashes cannot be broken.

### Incentives

Faulty full nodes may benefit from lying to the lite client, e.g., if
the lite client accepts a block that deviates (e.g., contains
  additional transactions) from the one generated
by Tendermint consensus. Users using the lite client might be harmed
by accepting a forged header.

In combination with the lite client failure detector,
correct full nodes have the incentive to respond, because the failure detector of the lite client may help them to understand whether their header is a good one. We can thus base liveness arguments on the assumptions that correct full nodes reliably talk to us.



### Assumptions

**[LCV-A-Full]** The verifier communicates with a full node called _primary_. No assumption is made about the full node (it may be correct or faulty).

**[LCV-A-Comm]**  Communication between the lite client and a correct full node is reliable and bounded in time.

**[LCV-A-TFM]** The Tendermint block chain satisfies the Tendermint failure model [TMBC-FM-2THIRDS].

**[LCV-A-LCC]** The lite client is following the protocol (it is correct).

## Distributed Problem Statement

> safety specifications / invariants in English


> liveness specifications in English. Possibly with timing/fairness requirements:
e.g., if the component is connected to a correct full node and communication is
reliable and timely, then something good happens eventually.

> should have clear formalization in temporal logic.

### Design choices

**[LCV-D-State]** The lite client has a local data structure called _State_ that contains headers.

**[LCV-D-State-Init]** Trusted State is initialized with _inithead_ that was correctly generated by the Tendermint consensus.

### Temporal Properties

**[LCV-VC-Inv]** At all times, every header in _State_ was generated by an instance of Tendermint consensus.

**[LCV-VC-Live]**
From time to time, verifier is called with a height _h_. Each instance must eventually terminate. The instance adds a header _hd_ with height _h_ to _State_ if

  - the _primary_ is correct

  - _State_ contains a header whose age is less than the trusting period.

_Remark_: The definitions imply that if _primary_ is faulty a header may or may not be added to _State_. In any case, [LCV-VC-Inv] must hold.

_Remark_: The invariant [LCV-VC-Inv] and liveness requirement [LCV-VC-Live]
allow that headers are added to _State_ whose height was not passed
to the verifier (e.g., intermediate headers used in bisection; see below).

_Remark_: In liveness [LCV-VC-Live]we use "eventually", while in practice _trust(h)_ should be set to true before _h.Header.bfttime + tp_. If not, the block cannot be trusted because it is too old.

### Solving the sequential Specification

This specification provides a partial solution to the sequential specification.
The verifier (this document) solves the invariant of the sequential part

[LCV-VC-Inv] -> [LCV-Seq-Inv]

In the case the primary is correct, and there is a recent header in _State_, the verifier satisfies the liveness requirements.

/\ "correct primary"  \
/\ \Exists TrustedState in State. TrustedState.SignedHeader.Header.Time > now - tp_
/\ [LCV-A-Comm] /\ [TFM-CorrFull] /\ [LCV-VC-Live]  \
       -> [LCV-Seq-Live]


## Definitions
> In this section we become more concrete, with basic data types,

> some math that allows to write specifications and pseudo code solution below.
Some variables, etc.

### Data structures

In the following, only the details of the data structures needed for this specification are given.

 ```go
   type Header struct {
        Height               int64
        Time                 Time          // the chain time when the header (block) was generated

        LastBlockID          BlockID       // prev block info
        ValidatorsHash       []byte        // hash of the validators for the current block
        NextValidatorsHash   []byte        // hash of the validators for the next block
   }

   type SignedHeader struct {
        Header        Header
        Commit        Commit            // commit for the given header
   }

   type ValidatorSet struct {
        Validators         []Validator
        TotalVotingPower   int64
   }

   type Validator struct {
        Address       Address           // validator address (we assume validator's addresses are unique)
        VotingPower   int64             // validator's voting power
   }

   type TrustedState {
        SignedHeader   SignedHeader
        ValidatorSet   ValidatorSet
   }
 ```

### Functions

For the purpose of this light client specification, we assume that the Tendermint Full Node
exposes the following functions over Tendermint RPC:
```go
    // returns signed header: Header with Commit, for the given height
    func Commit(height int64) (SignedHeader, error)

    // returns validator set for the given height
    func Validators(height int64) (ValidatorSet, error)
```

Furthermore, we assume the following auxiliary functions:
```go
    // returns true if the commit is for the header, ie. if it contains
    // the correct hash of the header; otherwise false
    func matchingCommit(header Header, commit Commit) bool

    // returns the set of validators from the given validator set that
    // committed the block (that correctly signed the block)
    // it assumes signature verification so it can be computationally expensive
    func signers(commit Commit, validatorSet ValidatorSet) []Validator

    // returns the voting power the validators in v1 have according to their voting power in set v2
    // it does not assume signature verification
    func votingPowerIn(v1 []Validator, v2 ValidatorSet) int64

    // returns hash of the given validator set
    func hash(v2 ValidatorSet) []byte
```




## Solution

> Basic data structures. Simplified, so that we can focus on the distributed
algorithm here. If existing: link to Tendermint data structures, and mentioned
if details were omitted.

> Pseudo code of the solution

Configuration Parameters:
- _trustThreshold float_:
- _trustingPeriod Duration_:
- _clockDrift Duration_:


### Outline

This is the signature of the function whose call is mentioned in
[LCV-VC-Live]. It implements the problem statement.

```go
func VerifyHeaderAtHeight(untrustedHeight int64,
                          trustedState TrustedState,
                          ) (TrustedState, error))
        expects: trustedState within trustingperiod from now
        returns: the header of height untrustedHeight, when the
                 header is consistent with the blockchain and
                 primary is correct (Commit and Validators do not produce errors)
                 error, otherwise
```

**[LCV-INTF]** _State_ is supposed to be maintained outside of this specification. When _VerifyHeaderAtHeight_ is called, _trustedState_ is in _State_. When _TrustedState_ is returned it is added to _State_.

`VerifyHeaderAtHeight` checks timestamps, and in case these preliminary checks go through, calls bisection: The function `VerifyBisection` implements
the recursive logic for checking whether it is possible to build a trust
relationship between `trustedState` and untrusted header at `untrustedHeight`.

```go
func VerifyBisection(untrustedHeight int64,
                     untrustedSh // fix
                     trustedState TrustedState,
                     now Time) (TrustedState, error)


        // enumerate here all the checks in untrustedSh
        returns: untrustedSh, when it is consistent with blockchain,
                              untrustedSh.Time > now + clockDrift,
                              and primary is correct
                 error, otherwise
```

To do so, `VerifyBisection` first downloads the necessary information
from the _primary_:

```go
func query_primary(untrustedHeight int64) (SignedHeader, Header, ValidatorSet, ValidatorSet)
Nominal postcondition:
    Returns: SignedHeader of height untrustedHeight
             Header hd of height untrustedHeight
             ValidatorSet of height untrustedHeight
             ValidatorSet of height untrustedHeight
    let hd be the second returnvalue
             hd.Time < now + clockDrift
Fails: on error in RPC or if postcondition is violated
```
**Question:** Does Commit ensure that the returned header is of the
correct height?

if `query_primary` returns without fault, `VerifyBisection` calls `VerifySingle`:


```go
func VerifySingle(untrustedSh SignedHeader,
                  untrustedVs ValidatorSet,
                  untrustedNextVs ValidatorSet,
                  trustedState TrustedState,
                  now Time) (TrustedState, error)
```

The function `VerifySingle` attempts to validate the given untrusted header and the corresponding validator sets
based on a given trusted state (the header with the largest height in _State_). It checks that the trusted state is still within its trusted period,
and that the untrusted header is within assumed `clockDrift` bound of the passed time `now`.

The remaining checks verify that the header is properly signed (by more than 2/3 of the voting power) by the right validators, and finally there are checks for two distinct cases:

 - if the headers are adjacent: check that the next validator hash in the _trustedState_ matches the validator hash of _untrustedSh_.

 - otherwise, the skipping case: check that the signers in _untrustedSh_ account for more than _max(1/3, trustLevel)_ of the voting power in the _trustedState_
 (this ensures that there is at least one correct validator in the set of signers)



*Remark:* This function is not making external (RPC) calls to the full node; the whole logic is
based on the local (given) state.

If `VerifySingle` is successful, it returns _TrustedState_ to `VerifyBisection` which in turn also returns _TrustedState_. Otherwise (and there is no fatal error), `VerifyBisection` computes a pivot height between _trustedState.height_ and _untrustedHeight_, and goes into recursion.

### Details

```go
func VerifyHeaderAtHeight(untrustedHeight int64,
                          trustedState TrustedState,
                          trustThreshold float,
                          trustingPeriod Duration,
                          clockDrift Duration) (TrustedState, error)) {

    trustedHeader := trustedState.SignedHeader.Header

    now := System.Time()
    if !isWithinTrustedPeriod(trustedHeader, trustingPeriod, now) {
        return (trustedState, ErrHeaderNotWithinTrustedPeriod)
    }

    newTrustedState, err := VerifyBisection(untrustedHeight,
                                            untrustedSh
                                            trustedState,
                                            now)

    if err != nil return (trustedState, err)

    now = System.Time()
    if !isWithinTrustedPeriod(trustedHeader, trustingPeriod, now) {
        return (trustedState, ErrHeaderNotWithinTrustedPeriod)
    }

    return (newTrustedState, err)
}
```




```go
func VerifyBisection(untrustedHeight int64,   
                     trustedState TrustedState,
                     now Time) (TrustedState, error) {

    // Check: ErrRequestFailed, ErrInvalidHeaderTime,
    // ErrInvalidHeaderTime:
    // preconditions on Sh. If not met, implementation must deal //
    // with it with error codes.

    untrustedSh, untrustedHeader, untrustedVs, untrustedNextVs := query_primary(untrustedHeight)




    result = verifySingle(
             trustedState,
             untrustedSh,
             untrustedVs,
             untrustedNextVs,
             trustThreshold)

    if result == OK {
        // the untrusted header is now trusted.
        newTrustedState = TrustedState(untrustedSh, untrustedNextVs)
        return (newTrustedState, nil)
    }
    else if result == InsufficientVotingPower {
     // at this point in time we need to do bisection
    pivotHeight := ceil((trustedHeader.Height + untrustedHeight) / 2)

    error, newTrustedState = VerifyBisection(pivotHeight,
                                             trustedState,
                                             now)
    if error != nil return (newTrustedState, error)

    return VerifyBisection(untrustedHeight,
                           newTrustedState,
                           now)
    }
    else {
        // header bad. there was a fault. escalate!
        // return (trustedState, error)
    }


}
```

TODO (copy code of procedures from https://github.com/tendermint/spec/blob/master/spec/consensus/light-client/verification.md or shouldn't we?)
-> no, stay more abstract

what does it mean that a header is OK. Defined as conditions not defined
as code.


## Correctness arguments

> Proof sketches of why we believe the solution satisfies the specifications.
Possibly giving inductive invariants that can be used to prove the specifications
>Link to Part I



### Why the protocol implements the distributed spec

> distributed algorithm correctness proof comes here.
